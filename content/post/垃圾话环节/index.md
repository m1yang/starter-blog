---
title: '网络基础'
subtitle: '常用垃圾话'
summary: 有感情地朗读全文并背诵第三段和最后一段
authors:
- miyang
tags:
- 网络基础
categories:
- 网络通信
- 协议
date: "2016-04-20T09:33:46Z"
lastmod: "2019-04-17T00:00:00Z"
featured: false
draft: false

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Placement options: 1 = Full column width, 2 = Out-set, 3 = Screen-width
# Focal point options: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight
image:
  placement: 2
  caption: ''
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---

## 我们的网络

随着科技的发展，我们的文字已经不仅仅活跃在纸张上了，各种电子设备可以用来显示文本及与文本相关的内容。就像装订书籍一样，也需要将这些文本连接起来，这种连接的方式我们称为**超链接** ，这样的文档我们称为**超文本** ，这样装订成册的书籍我们之间需要互相传阅，于是便形成了**万维网**  。

> **超文本**（英语：**Hypertext**）是一种在电脑显示器或其他电子设备，用以显示文本及与文本相关的内容，其中的文字包含有可以链接到其他字段或者文档的超链接，允许从当前阅读位置直接切换到超链接所指向的文字。

所以，从这样的角度看，**万维网** 更像是个图书馆。我们需要通过图书管理员**URL** (统一资源定位符)来找到自己想要借阅的书籍，而去取到对应的书籍我们需要有一个约定俗成的方法，即**HTTP** (超文本传输协议)，当然我们也得知道每本这样的书主要是由**HTML** (超文本标记语言)完成的。

<!--more-->

> **万维网**（英语：*World Wide Web*），亦作“WWW”、“Web”，是一个由许多互相链接的超文本组成的系统，通过互联网访问。
>
> 万维网是信息时代发展的核心，也是数十亿人在互联网上进行交互的主要工具。网页主要是文本文件格式化和超文本标记语言（HTML）。除了格式化文字之外，网页还可能包含图片、视频、声音和软件组件，这些组件会在用户的网页浏览器中呈现为多媒体内容的连贯页面。

而科技却不仅仅局限于文本，图片、视频、声音等与文本相关的各种资源通过**HTML** 、**CSS** 、**JavaScript** 这些技术一起构成了**网页** 。网页的合成体称为**网站**，一个网站的开始点称为**首页**，而我们则通过浏览器来访问这些网站。

提供万维网这样类似的服务，并以一组标准的网络**TCP/IP协议族** 将所有的服务连接起来形成一个庞大网络，也就是**互联网** ，像对等网络、文件分享、以及网络协议通话技术都由其提供。

> **互联网**或**国际网**（英语： The Internet），是网络与网络之间所串连成的庞大网络，这些网络以一组标准的网络TCP/IP协议族相连，连接全世界几十亿个设备，形成逻辑上的单一巨大国际网络。它是由从地方到全球范围内几百万个私人的、学术界的、企业的和政府的网络所构成，通过电子，无线和光纤网络技术等等一系列广泛的技术联系在一起。这种将计算机网络互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的网络。
>
> 互联网并不等同万维网（WWW），万维网只是一个基于超文本相互链接而成的全球性系统，且是互联网所能提供的服务其中之一。互联网带有范围广泛的信息资源和服务，例如相互关系的超文本文件，还有万维网的应用，支持电子邮件的基础设施，对等式网络，文件共享，以及网络协议通话技术。

## 网络的基础

计算机与网络设备要互相通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要事先确定，都需要一种规则。而我们就把这种规则称为协议(protocol)。

协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等。像这样把与互联网相关联的协议集合起来总称为TCP/IP。

> **互联网协议族**（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。
>
> 它常被通称为**TCP/IP协议族**（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称**TCP/IP**。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。
>
> 由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为**TCP/IP协议栈**（英语：TCP/IP Protocol Stack）。
>
> 这些协议最早发源于美国国防部（缩写为DoD）的ARPA网项目，因此也被称作**DoD模型**（DoD Model）。

毕竟网络通信不是像传话那样简单，嚎两声就可以了。若只有一个网络协议来统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。所以我们需要协议层次化，整个通信网络的任务，可以划分成不同的功能区块，即所谓的层级。所有这些协议都在相应的**RFC文档** 中讨论及标准化。用于互联网的协议可以比照**TCP/IP参考模型** 进行分类。

**TCP/IP参考模型** ：

* **应用层** (application layer)：该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。 

  该层常见的协议有：HTTP、FTP、DNS等

* **传输层** (transport layer)：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。

  该层常见的协议有：TCP、UDP等

* **网络互连层** (internet layer)：网络层规定了通过怎样的传输路线到达对方计算机，并把数据包传送给对方。即寻址。

  该层常见的协议有：IP、ARP等

* **网络接口层** (link layer)：用来处理连接网络的硬件部分。

  该层常见的协议有：以太网、Wi-Fi等

利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。

## 协议的实现

### HTTP(超文本传输协议)

> HTTP是一个客户端（用户）和服务器（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器或者隧道（tunnel）。

#### 一、请求与响应

那么我们首先了解下HTTP协议的请求与响应具体是如何表现的

> 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

我们访问github，上去抓个包，便可以得到类似以下信息：

```http
客户端
GET / HTTP/1.1
Host: github.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.8
Cookie: ......

```

```http
服务器
HTTP/1.1 200 OK
Date: Thu, 21 Dec 2017 11:41:36 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Server: GitHub.com
Status: 200 OK
Cache-Control: no-cache
Vary: X-PJAX
X-UA-Compatible: IE=Edge,chrome=1
Set-Cookie: ......

（紧跟着一个空行，并且由HTML格式的文本组成了GitHub的主页）
```

**请求报文:** 

* 请求方法、请求URI、协议版本
* 请求首部字段(除Host外，均可选)
* 空行
* 内容实体(可选)

**响应报文:** 

* 协议版本、状态码、状态码原因短语
* 响应首部字段(可选)
* 空行
* 内容实体(可选)

#### 二、请求方法

为了区分获取资源的方式，HTTP协议定义了几种方法来操作指定的资源，下面介绍最为常见的五种。

| Method | 安全性  | 幂等性  | 说明                            |
| ------ | :--: | :--: | ----------------------------- |
| GET    |  √   |  √   | 向指定资源发出"显示"请求，一般是查询资源。        |
| POST   |  ×   |  ×   | 向指定资源提交数据，请求服务器进行处理。可创建和更新资源。 |
| PUT    |  ×   |  √   | 向指定资源位置上传其最新内容，即替换资源。         |
| PATCH  |  ×   |  √   | 将局部修改应用到资源。                   |
| DELETE |  ×   |  √   | 请求服务器删除所标识的资源。                |

- **安全性**：任意多次对同一资源操作，都不会导致资源的状态变化。
- **幂等性**：任意多次对同一资源操作，对资源的改变是一样的。

注意：安全性在协议规定中是指请求方法对指定资源操作会产生副作用，即是否会改变资源状态。会导致资源状态变化的，称为"非安全"方法，例如POST，PUT及DELETE，这样的请求会修改、创建甚至是删除指定资源。

不过通常来说我们在HTTP协议中使用最多的方法便是GET和POST了，所以这里主要展示GET和POST的区别，这也是面试中最常被问到的内容：

|           | GET                                      | POST                                     |
| --------- | ---------------------------------------- | ---------------------------------------- |
| 返回按钮/重新加载 | 无副作用                                     | 数据将被重新提交(浏览器应该提醒用户数据即将被重新提交)             |
| 书签        | 可以加书签                                    | 不可以加书签                                   |
| 缓存        | 可以被缓存                                    | 不可以被缓存                                   |
| 编码类型      | application/x-www-form-urlencoded只能进行url编码 | application/x-www-form-urlencoded or multipart/form-data.用multipart对二进制数据进行编码。支持多种编码方式 |
| 历史记录      | 参数保留在浏览器历史记录中                            | 参数不保留在浏览器历史记录中                           |
| 限制数据长度    | 是的，在发送数据时，GET方法将数据添加到URL; 而URL的长度是有限的（最大URL长度是2048个字符） | 对数据长度没有限制                                |
| 限制数据类型    | 只允许ASCII码                                | 对数据类型没有限制，二进制数据也是可以使用的。                  |
| 安全性       | 与POST相比，GET的安全性较低，因为发送的数据是URL的一部分。发送密码或其他敏感信息时切勿使用GET！ | POST比GET更安全，因为这些参数不存储在浏览器历史记录或Web服务器日志中  |
| 能见度       | 所有人都可以在URL中读到数据                          | 数据不会显示在URL中                              |

注意：这里的安全性指的是信息泄露或是被窃取的可能性。

#### 三、响应状态码

所有HTTP响应的第一行都是**状态行**，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。

状态代码的第一个数字代表当前响应的类型：

- 1xx消息——请求已被服务器接收，继续处理
- 2xx成功——请求已成功被服务器接收、理解、并接受
- 3xx重定向——需要后续操作才能完成这一请求
- 4xx请求错误——请求含有词法错误或者无法被执行
- 5xx服务器错误——服务器在处理某个正确请求时发生错误

虽然 RFC 2616中已经推荐了描述状态的短语，例如"200 OK"，"404 Not Found"，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。

#### 四、HTTP状态管理

**Cookie** ：指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。

因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。

**会话**（**session**）是一种持久网络协议，在客户端和服务器端之间创建关联，从而起到交换数据包的作用机制。

会话(session)往往使用Cookie来管理，例如我们的登录认证。

1. 首先，客户通过POST方法将请求发送给服务器。
2. 这时候服务器会发放识别用户的Session ID，通过验证从客户端发送过来的登录信息进行身份认证，然后把用户认证状态与Session ID绑定后记录在服务端。向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID(为了防止被盗或被猜出，Session ID的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串并且服务器端也需要进行有效期的管理，保证其安全性)。
3. 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。

因为cookie和session都有保持HTTP状态的功能，所以他们两个也常常被拿出来比较。

简单来说主要区别：

session:存储在服务器，更安全，当关闭浏览器后会话同样也会关闭。

cookie:存储在客户端，不安全，在到期和被删除前将一直有效。

### TCP(传输控制协议)

> TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。
>

TCP将大块数据分割成已报文段为单位的数据包，并给数据包提供可靠的传输服务。IP协议的作用是把各种数据包传送给对方。

> 应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。
>
> TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。

TCP传输的时候主要会说到三次握手与四次挥手，若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。

**三次握手:** 

* C(SYN)：洞拐洞拐，我是洞幺。这里有份急电要传给你。
* S(SYN，ACK)：洞幺洞幺，我是洞拐。已确认可以接受电报。
* C(ACK)：收到，OVER。着手发电报。

**四次挥手:**

* C(FIN)：电报发送完毕，请求关闭(等待回复FIN_WAIT_1)
* S(ACK)：收到，需要确认信息是否传输完毕，请稍等。(确认数据传输完成CLOSE_WAIT)
* S(FIN)：已确认可以关闭(等待确认LAST_ACK)
* C(ACK)：收到，OVER。(完成关闭TIME_WAIT)

补充：第三次握手失败会怎样？

当客户端收到服务端的SYN+ACK应答后，其状态变为ESTABLISHED，并会发送ACK包给服务端，准备发送数据了。如果此时ACK在网络中丢失，过了超时计时器后，那么Server端会重新发送SYN+ACK包，重传次数默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误。

### IP(网际协议)

> IP（英语：Internet Protocol）的任务是仅仅根据源主机和目的主机的地址传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。
>

这里先介绍IP的寻址，如何将IP地址分配给各个终端节点，以及如何划分和组合子网。

> **IP地址**（英语：IP Address），是分配给网络上使用网际协议IP的设备的数字标签。常见的IP地址分为IPv4与IPv6两大类。

目前最主要的仍是IPv4，而IPv6还在积极部署中。

最初，一个IP地址被分成两部分：网络识别码在地址的高位字节中，主机识别码在剩下的部分中。

为了克服这个限制，在随后出现的分类网络中，地址的高位字节被重定义为网络的*类*(Class)。这个系统定义了五个类别：A、B、C、D和E。A、B和C类有不同的网络类别长度，剩余的部分被用来识别网络内的主机，这就意味着每个网络类别有着不同的给主机编址的能力。D类被用于多播地址，E类被留作将来使用。

由于分类网络的可拓展性不足且会给路由设备增加额外的负担，无类别域间路由（CIDR）正式地取代了分类网络。

> **无类别域间路由(CIDR)**是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。

这个解释起来就超纲了，但还是在这挖个坑，填不填看缘了。

注：IP地址也分公网和内网，由**网络地址转换**(NAT)实现。

**注意：**虽然DNS和URI是应用层的协议，但是因其与IP地址关联甚大，于是乎就写在IP协议下面了。

#### 域名系统DNS

我们很难通过输入一组纯数字来区分需要访问的IP地址，所以就有了方便人类记忆的域名(由字母搭配数字)。可计算机不擅长处理名称，这就需要有域名到IP地址之间的解析服务，即DNS。这样我们只需要输入易于记忆的域名，然后通过DNS解析为IP地址进行访问。

```http
域名划分：
.com 顶级域名
baidu.com 一级域名
www.baidu.com 二级域名
bbs.baidu.com 二级域名
tieba.baidu.com 二级域名
```

tips:`www.`作为域名前缀起到主域名与子域名区分的作用

#### 统一资源标志符

可如果访问地址数据量大、资源丰富的话，我们该如何去取到想要的资源呢？这便是URI(统一资源标识符)的作用了。

> URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。
>
> 用于标识唯一书目的ISBN系统是一个典型的URN使用范例。例如，ISBN 0-486-27557-4( \<urn:ISBN> 0-486-27557-4 )无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个URL地址。在类Unix操作系统中，一个典型的URL地址可能是一个文件目录，例如file:///home/username/RomeoAndJuliet.pdf。该URL标识出存储于本地硬盘中的电子书文件。因此，URL和URN有着互补的作用。

我们在浏览器上输入的网址具体解析如下：

| http:// | user:passwd@ | www.example.com | :80    | /dir/index.html | ?uid=1 |
| ------- | ------------ | --------------- | ------ | --------------- | ------ |
| 协议名     | 认证信息(可选)     | 服务器地址           | 服务器端口号 | 文件路径            | 查询字符串  |

**tips:**

* **格式化文本**与纯文本相对，具有风格、排版等信息，如颜色、式样(黑体、斜体等)、字体尺寸、特性(如超链接)等。

* **格式化**是指对磁盘或磁盘中的分区（partition）进行*初始化*的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除。

* 有些人往往会弄不清在计算机中出现的“位”和Byte,KB,MB等有何关系，而它们的关系是，8位等于一字节Byte，即8bit=1B 。32位处理器每次处理 4Byte(32bit)，同理，64位处理器每次处理 8Byte(64bit)

  在 ASCII 编码中，一个英文字母字符存储需要1个字节。在 `GB 2312` 编码或 `GBK` 编码中，一个汉字字符存储需要2个字节。在`UTF-8`编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。


# cookie和session找不同
## 二者的定义：

当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。

> 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。

同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。

## cookie机制

正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。

cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。

会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。

## session机制

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。

## url重写

经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： 

```html
<form name="testform" action="/xxx"> 

<input type="hidden" name="jsessionid" value="ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764"> 

<input type="text"> 

</form>
```

实际上这种技术可以简单的用对action应用URL重写来代替。

## 区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
5. 所以个人建议：
* 将登陆信息等重要信息存放为SESSION
* 其他信息如果需要保留，可以放在COOKIE中