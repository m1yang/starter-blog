---
# Documentation: https://sourcethemes.com/academic/docs/managing-content/

title: "为什么测试总是吃力不讨好"
subtitle: ""
summary: "测试不会编码就是行走的点读笔，运维不会编码就是行走的指令集"
authors: [admin]
tags: []
categories: [测试,想法]
date: 2020-10-11T19:32:39+08:00
lastmod: 2020-10-11T19:32:39+08:00
featured: false
draft: false

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---
从两个点来讲测试的这个问题，一是全面性 一是准确性

特别烦的一种测试情况，类似于函数有个自增变量
你：这就是x=x+1，看一眼就知道结果了，不用测
他：怎么不用测，程序结构那么复杂，谁知道哪影响到哪了，万一x输入个1，出来个3怎么办，出了问题你负责么，还是要测
再说的夸张点就是：每天早上起来，非要拿指南针看看太阳是不是东边升起的，万一因为宇宙抽搐了，太阳打西边出来了，那得赶紧做准备啊

但是测试也往往遇到另一种情况，就像白色巨塔里面一样，财前草率下决定进行手术，没能真正发现问题所在，导致病情复发悲剧产生。虽然财前在医疗技术上并不属于过失，但他的私心与自大，没能严谨对待病症，造成了无法挽回的后果。
![](财前.png)

两个举例看上去是矛盾的，但其实不然，前者是忽视了准确性，单方面考虑全面性。后者是具备了准确性，但是却没有再深入检查。

准确性需要非常专业的知识，才能做到，而往往测试人员并不具备这种能力。所以就造成了这样一种局面：
病人：医生，我就是牙疼，为什么一来又要做全身扫描？
医生：医学的事是那么简单能说清楚的么，对病人的身体健康复杂，必须要做全面的检查。你以为是牙齿的问题，但可能是肾脏出了问题呢？等下再做个脑部CT，万一有肿瘤什么的，早发现早治疗。
病人：真就只是牙疼，把牙看了就行了，我还要回去上班呢！
医生：上班？命都不要了！检查充分了，问题都解决了，再和我说别的。
(自己瞎编的，自身看病真实的体验是，医生一般都会先让你描述病情再决定是否做进一步检查)

对于'医生'的尽职尽责，你也没法说什么。但是看一次牙就这么折腾一次，别的事也真就干不了了。这样的场景，在日常的测试工作中一直在上演，“万一产线出问题了呢”、“这里修改了一点点，你都测一遍吧”、“测试用例都覆盖了没，看看有没有遗漏的”。。。
丧失了这种专业性，整个工作内容的实质在形象的宣传上原大于实际的作用。

测试手法中，常见的，点开两个页面，然后依次提交当前页面内容。为什么要这样测？这样测试有什么用？
通常来说，这种测试手法是对后端接口进行2次提交。单页面情况下，一次提交后，会根据后端返回的内容进入到下一个状态。但是点开两个页面，第二个页面提交时，后端以及处理过当前提交了，状态往往进入下一阶段，这时候会给出前端对于的提示。
所以说，这里的测试，打开两个页面不是必要的，对后端接口重复提交的测试以及前端页面是否会根据后端接口返回准确相应的测试才是必要的。

还有最常见的，文本溢出的测试。就web来说，这里通常测试的是overflow属性，
```css
/* 默认值。内容不会被修剪，会呈现在元素框之外 */
overflow: visible;
/* 内容会被修剪，并且其余内容不可见 */
overflow: hidden;
/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */
overflow: scroll;
/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */
overflow: auto;
```

这时候，无论你怎么拉伸浏览器，都测不出个所以然来的。

当测试失去了准确性，却又过分强调全面性，就很容易闹笑话出来，作为笑话的主角，明明尽心尽力，却仍很难让人高看一筹。尤其是测试作为一个质量团队，并没有把控质量的能力，而是把工作的重心放在了用例覆盖率、bug数量、自动化程度这些考核数值上。没能看到问题的核心，就算提炼出一个测试开发团队，也只是在加速这一错误过程。

扯了半天，问题究竟出现在哪？在于测试体系的断层。

功能测试也好、自动化测试也好、开发效率工具也好，都是在终端作业，而基础的单元测试却没有涉及。产品需求和代码实现并不一致，就会出现bug，而实现bug的逻辑是没法用方法论去分析的。在软件功能日益复杂的今天，黑盒测试的手法早就难以适用了，需求的描述并不是代码实现的过程，没有了甲方乙方，真正的需求分析得从代码入手。本来是需要在代码层面发现的bug，是属于函数的逻辑，遗留到功能层面了，你要通过分析产品的需求来找到函数逻辑的漏洞，这谁能做的好？不完善的测试体系导致的就是测试内容的没有边际，只能一遍又一遍的强调再测一遍，企图通过数量的溢出到达质量的效果。

建立质量体系，明确单元测试能保证什么-保证运算正确，保证对基本参数的运算正确。而功能测试保证什么-保证集成后的效果符合需求。代码和功能是两个大的范畴，性能测试、集成测试等都属于这两大范畴的细分场景(在我看来，集成测试是测试过程的拆分，将整体拆成部分去测试。前后端数据分离的测试，准确描述为API测试。)。

喊口号要求测试人员的开发水平，也不能做到全面与精准。将过程的每一步做对，聚沙成塔，站在塔上，才能省力又叫好。

（并没有专门的书籍指导，只是自己经验的总结，觉得不可信就当作是吐槽好了）