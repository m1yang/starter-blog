---
title: '编程随想'
subtitle: '记录了自己学编程的几个阶段'
summary: '编程最常见的就是赋值语句 `x= expr`，如何理解和记忆这段语句基本贯穿了目前我整个编程学习过程。'
authors:
- admin
tags: []
categories: []
date: "2020-10-10T00:37:49+08:00"
lastmod: "2020-10-22T00:37:49+08:00"
featured: false
draft: false
---

# 第一阶段
编程最常见的就是赋值语句 `x= expr`，如何理解和记忆这段语句基本贯穿了目前我整个编程学习过程。

最初，需要明白什么是面向过程？什么是面向对象？

搜索引擎里有大段大段的描述，抽象、封装、可重用，类、继承、多态，WTF。用概念去理解概念真是我当年干过最傻B的事情。

其实理解面向过程、面向对象并不重要。构建出'对象'这一概念，就是因为过程中重复性的代码太多，同样一套流程换个名字、换个地方，难道就又得重写一遍吗？抛开驳杂的定义，重要的其实就一点**避免重复**，然后一切的一切都是围绕着这一点的*最佳实践*。

落到实处，实例化就是最明显的分界线，`x= new className`。className里的代码不再处理具体的某一件事，它只是一套模板，一张图纸，你需要将它新建(new)出来，才能使用。

掌握这一技巧后，我写什么代码都是class里裹了一层层方法，然后实例化出来调用它们，我以为编程不过如此，但是错了，一开始就错了。


# 第二阶段
这还要从一个编程的笑话讲起[不适合编程的人是怎样的？](https://www.zhihu.com/question/340415734/answer/920077866)，“你给我一个例子我就服，哪个数等于它加一？”我看得是表面笑嘻嘻，心里一惊惊，因为很长一段时间我都没试图去理解过`i=i+1`是什么意思，在我看来，它就是这样，没有缘由。然后我打开了搜索引擎，看了一大堆罗里吧嗦的文章后，我觉得我悟了。

这时候，我明确的知道，要以等号为界点，左边是变量，右边是表达式。开始用大脑而不是眼睛去区分等式与赋值。我开始了，表达式可以粗暴的概括为一切用于运行计算的数字和符号，那么`i=i+1`其实写成`y=x+1`就明白了，x是自变量，y是因变量，就是个普通到不能再普通的一次方程求值。而在程序里，恰好因变量和自变量一样，所以实现了自增的效果。

数字可以自增，字符串也可以自增，对象都可以自增，我悟了！莫名地我对之前实例化也有了不一样的理解。

动态语言像python，经常看到类似`self.name=name`，左边是name右边也是name，这种写法，曾经一度我以为传入的参数要和实例化对象拥有一样的名字。但其实是可以不一样的，`self.eman=name`，实例化出来的属性是eman。例如，`x= new className`，x是变量，x.eman也是变量，而name只是传入参数的一个标识。这时候我才真正明白过来，这个self就是指代实例化对象的，而以前也并不是不明白，而是被网上一大堆文章，一大堆说法迷了眼睛，总以为是个很底层、很复杂的东西。

这个认识虽然没有什么卵用，但是去繁就简，让我对赋值和实例化的认识更加清晰了

![然而这并没有什么卵用](qiguaidezhishi.jpg)

# 第三阶段
恰逢工作需要，开始了对golang的学习。当时真是，不仅工作要加班，工作之外还要腾出时间来学新语言。折腾了大半年，硬着头皮用golang写出来了一个项目。不得不说，这次的折腾对我来说确实值，python这门胶水语言，帮用户做了很多事情，但这也让用户对编程的认识并不全面。

虽然不知道为什么golang在知乎被吐槽的这么厉害，但是我能感觉到这门语言的作者是真的在思考一门编程语言最少需要保留些什么，而什么又可以剔除掉。比如说指针，python都没有给到你这个概念，但是指针又的的确确存在python中。golang不仅保留了指针还简化了它的操作，而其对interface的定义（没有结构，而是表现自身具有哪些方法），真是惊艳到了我（虽然用起来不那么香）。然后我想再强调一下，golang真的是那几个牛批的作者将其对编程的思考带入了进去。

随着对golang的学习，除了开眼界外，更重要的是强化了对指针的认识。于是`var 变量名字 类型 = 表达式` 语句在我眼里又有了不同。指针强调是存储内存地址而不是实际的值，那么`var 变量名字 类型`也就是向系统申请内存地址，此时赋值就是在该内存地址存储一个值。而指针，存储的是内存地址。在一个内存地址上存储另一个内存地址，这有啥用呢？

进一步的思考，让我又去了解了求值策略。提取实际对我有收益的点，也就是函数调用时，变量是如何作为参数传入的。在传入变量本身可变的情况下：
1. call by value：拷贝变量的值传入，函数求值不影响变量
2. call by reference：传入变量的地址(拷贝地址也还是地址)，不仅可以修改变量，还可以给变量重新赋值
3. call by sharing：传入共享对象(我的理解是不同的地址指向同一个值)，这样的好处是，可以修改变量，但是赋值只是对参数重新赋值，不影响变量。python,js都是用的这一策略。

其实这里reference和sharing是极难区分的，网上的文章又乱七八糟的，所以我以一个点来界定，就是求值是否会修改变量的内存地址，不会就是call by sharing。然后试了试golang的指针，符合sharing。

赋值在我眼里，从定义一个变量，变成了申请一个地址来存储值。

(tips:还是有个地方没懂，golang指针出现在等式右边时，编译时是指针本身的地址还是指向的地址)

# 第四阶段
golang做到了simple，但并不easy，或者说，并不stupid。人不能，至少不应该...把自己有限的时间投入到后端无限的探索中去。又是恰逢工作需要，转投JavaScript的怀抱。之前也有使用js，但其实自己压根没看过js的语法，全凭着对编程的一丢丢知识结合搜索引擎，也能用！(虽说资历尚浅，只能被工作安排，不能安排工作，但在学语言这块还是自己做了墙头草。)

相比golang精良的设计，js真担的上‘残缺’两字，无论是文章、博客还是书籍，俨然已经习惯了把bug当feature。很多业内大佬都是一幅孔乙己做派，‘回字有四样写法,你知道么?’不可言喻的兴奋都能透过屏幕传达到我面前。

但在实际使用的过程中，我感到js的缺陷反而成了它的优势。一是别的语言都是告诉你‘我是对的，照着来就行’，js不这样，它就能让你明白为啥这样做是不对的。比如说等式判断，真没哪个语言两个‘=’不严谨还要加个‘=’才对。二是js真是太随意了，它的模块化、它的版本兼容，这和其它语言比起来，简直就是魔法！

这一块本来是想说，js浪的一批的同时，还给予了不少编译和运行时的奇巧知识。但是心里总觉着不对味，这些所谓底层原理都是文章、书本‘喂’给你的，而你只是记住了并不是弄懂了。虽然程序员中很多人鼓吹底层原理，其实真正能接触到、能用到的又有几个呢？那些鼓吹底层的，是不是因为他们进场早，不得不从底层学起呢？

> 一个程式在执行的时候一定会同时做以下几件事情：
> 1. 描述所要解决的问题
> 2. 按照计算的顺序分成几个部分执行
> 3. 同时处理内存管理 
> 
> 理想情况下，程序员应该只关注第一个问题（所要解决的问题），因为这个问题是更应该被关注。 ---Chris Reade

基于新研究出来的理论，可以编写出全新的产品。但是基于底层原理，最多也就是重复造轮子啊！一门优秀的编程语言设计出来，本就是希望程序员不用再过多的了解与业务无关的底层原理。解决问题才是夯实基础的最佳实践。为什么直到现在，头上还是得悬着‘祖宗功法不可变’几个大字？

回到最初的赋值语句 `x= expr`，理解为变量获取一个值也好，理解为内存地址存放一个值也好。它的上下文才决定了它的价值。知道怎么做之前，要得知道做什么。编程是一件长期反馈的事情，非要精通算法，精通各类设计模式，通晓底层原理才能编程的话，可能一辈子也写不出一个像样的产品。通过解决问题来不断改进自己的代码，不断升级自己的知识结构，才可能成为互联网的大手子。

描述了4个阶段，说了一大堆废话。只是感慨，以前我不知从哪揣来一句`语义化`，仿佛掌握了个多了不得的知识，但真正使用的时候才发现，不是所有的产品都是文章报纸，css+div才具有普遍适用性。无脑鼓吹语义化的我，现在看来真像个傻子。在花了很多时间探索无尽的深渊后，现在才明白过来，要朝着有光的地方走。对原理的理解，对代码的编写都不是最重要的，你写的代码嵌在怎样的产品里，这才是最重要的。

---

总结，花费多年，不过踏出一小步，明白了程序员不是用来学新技术、炫耀知识点的，是要用代码解决实际问题的。