---
title: '编程随想'
subtitle: '记录了自己学编程的几个阶段'
summary: 
authors:
- miyang
tags:
- 想法
categories:
- 工作
date: "2020-10-10T00:37:49+08:00"
lastmod: "2020-10-10T00:37:49+08:00"
featured: false
draft: true
---

# 第一阶段
编程最常见的就是赋值语句 `x= expr`，如何理解和记忆这段语句基本贯穿了我整个编程学习过程。

最初，需要明白什么是面向过程？什么是面向对象？

搜索引擎里有大段大段的描述，抽象、封装、可重用，类、继承、多态，WTF。用概念去理解概念真是我当年干过最傻B的事情。

其实理解面向过程、面向对象并不重要。构建出'对象'这一概念，就是因为过程中重复性的代码太多，同样一套流程换个名字、换个地方，难道就又得重写一遍吗？抛开驳杂的定义，重要的其实就一点**避免重复**，然后一切的一切都是围绕着这一点的*最佳实践*。

落到实处，实例化就是最明显的分界线，`x= new className`。className里的代码不再处理具体的某一件事，它只是一套模板，一张图纸，你需要将它新建(new)出来，才能使用。

掌握这一技巧后，我写什么代码都是class里裹了一层层方法，然后实例化出来调用它们，我以为编程不过如此，但是错了，一开始就错了。


# 第二阶段
这还要从一个编程的笑话讲起[不适合编程的人是怎样的？](https://www.zhihu.com/question/340415734/answer/920077866)，“你给我一个例子我就服，哪个数等于它加一？”我看得是表面笑嘻嘻，心里一惊惊，因为很长一段时间我都没试图去理解过`i=i+1`是什么意思，在我看来，它就是这样，没有缘由。然后我打开了搜索引擎，看了一大堆罗里吧嗦的文章后，我觉得我悟了。

这时候，我明确的知道，要以等号为界点，左边是变量，右边是表达式。开始用大脑而不是眼睛去区分等式与赋值。我开始了，表达式可以粗暴的概括为一切用于运行计算的数字和符号，那么`i=i+1`其实写成`y=x+1`就明白了，x是自变量，y是因变量，就是个普通到不能再普通的一次函数求值。而在程序里，刚好因变量和自变量一样，所以实现了自增的效果。

数字可以自增，字符串也可以自增，对象都可以自增，我悟了！莫名地我对之前实例化也有了不一样的理解。

动态语言像python，经常看到类似`self.name=name`，左边是name右边也是name，这种写法，曾经一度我以为传入的参数要和实例化对象拥有一样的名字。但其实是可以不一样的，`self.eman=name`，实例化出来的属性是eman。例如，`x= new className`，x是变量，x.eman也是变量，而name只是传入参数的一个标识。

这个认识虽然没有什么卵用，但是让我对赋值和实例化的认识更加清晰了

# 第三阶段
恰逢项目需要深入使用javascript，瞄了一眼*You Don't Know JS*，强行给脑袋里塞进去了左值右值的概念。而js不像其它语言那样捂得严实，借此机会又有了不一样的理解。

之前编程一直处于模板编程，也就是给什么样的模板，写什么样的代码
跟学英语一样，靠的不是语法而是语感，写代码靠的不是理解而是码感

求值策略、堆栈、可变与不可变、指针、引用

这些所谓底层原理都是文章、书本喂给你的，而你只是记住了并不是弄懂了。因为不曾参与AST、解释器、编译器的开发，语言内部是否真的是这样的逻辑，除非真的去看V8引擎代码，去尝试重新造轮子，否则只是眼睛看到了而已。

编译与运行时，python隐去了这些细节，但是js不得不去理解
赋值左值发生在编译时，右值发生在运行时

正确理解`let x = 1` 一句话，两个阶段。左边let x声明语句，发生在编译时期，x表示内存地址，告诉计算机我要用这个地址。右边=1，发生在运行事情，1可以是任意表达式，在程序启动后，计算出表达式的值并赋予给x，也就是在x这里内存地址里存储了一个计算得出的结果。

其实没有研究过编程语言是如何开发出来的，这些理解都是搜到什么文章，看过什么书，以多场景的方法记忆了下来，并不是真的弄懂了。虽然程序员中很多人鼓吹底层原理，其实真正能接触到的又有几个呢？毕竟不是设计编程语言的时代了，曾经的人花费苦心，就是希望设计出来的语言能减轻我们的记忆和理解负担，的确建房子都要打地基，但是有的设计烂尾楼有的设计埃菲尔，一个烂尾楼的地基，再牛逼有什么用呢？诚然这个例子不恰当，我想强调的是，需要什么技术解决什么问题，技术不是最重要的，解决问题才是。

了解底层原理，的确可以减轻不少记忆负担，毕竟越底层越通用